using LazyMagic.Client.ModelGenerator;
using Microsoft.CodeAnalysis;
using System.Data;

namespace LazyMagic.LzModelGenerator;


// Example1:
// namespace MyNamespace;
// [LzModelValidator("Yada")]
//
// Generated: YadaModelValidator.cs
// namespace MyNamespace;   
// public partial class YadaModelValidator : AbstractValidator<YadaModel>   
// {
//     public YadaModelValidator() 
//     {    
//         Include(new YadaValidator());
//     }
// }
//
// Example2:
// namespace MyNamespace;
// [LzModelValidator("Yada", false)]
//
// Generated: YadaModelValidator.cs
// namespace MyNamespace;   
// public partial class YadaModelValidator : AbstractValidator<YadaModel>   
// {
// }

[Generator]
public class LazyMagicModelValidatorGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor _messageRule = new(
        id: "LZI0002",
        title: "LazyMagic.Client.LzModelValidatorGenerator Source Generator Message",
        messageFormat: "{0}",
        category: "SourceGenerator",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the syntax provider to find classes with LzModelValidator attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetClassToGenerate(ctx))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!.Value);  // Convert from nullable to non-nullable

        // Register the output
        context.RegisterSourceOutput(classDeclarations,
            static (spc, classInfo) => Execute(spc, classInfo));
    }

    private static (string Namespace, string BaseClassName, bool IncludeDTO)? GetClassToGenerate(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var model = context.SemanticModel;

        // Check if the class has the LzModelValidator attribute
        var classSymbol = model.GetDeclaredSymbol(classDecl);
        if (classSymbol == null) return null;

        var hasAttribute = classSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.Name == nameof(LzModelValidatorAttribute));
        
        if (!hasAttribute) return null;

        // Get the attribute and its arguments
        var modelAttribute = classDecl.AttributeLists
            .SelectMany(a => a.Attributes)
            .FirstOrDefault(a => a.Name.ToString().EndsWith("LzModelValidator"));

        if (modelAttribute?.ArgumentList?.Arguments.Count < 1) return null;

        var args = modelAttribute.ArgumentList.Arguments;
        var baseClassName = args[0].Expression.ToString().Trim('"');
        var includeDTO = args.Count > 1 ? args[1].Expression.ToString().Trim('"').Equals("true") : true;
        var namespaceName = classSymbol.ContainingNamespace.ToString();

        return (namespaceName, baseClassName, includeDTO);
    }

    private static void Execute(SourceProductionContext context, (string Namespace, string BaseClassName, bool IncludeDTO) classInfo)
    {
        var includeDTOsource = classInfo.IncludeDTO ? $@"
    public {classInfo.BaseClassName}ModelValidator()
    {{
        Include(new {classInfo.BaseClassName}Validator());
    }}"
            : "";

        var source = $@"
// <auto-generated />
namespace {classInfo.Namespace};
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
public partial class {classInfo.BaseClassName}ModelValidator : AbstractValidator<{classInfo.BaseClassName}>
{{
{includeDTOsource}
}}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
";
        context.AddSource($"{classInfo.BaseClassName}ModelValidator.g.cs", source);
    }

    private static void Log(SourceProductionContext context, string? message)
    {
        if (message == null) return;
        string[] lines = message.Split(new[] { '\n' }, StringSplitOptions.None);
        foreach (var line in lines)
        {
            var diagnostic = Diagnostic.Create(_messageRule, Location.None, line);
            context.ReportDiagnostic(diagnostic);
        }
    }
}
namespace LazyMagic.Client.DIHelper;
// Register services having specified Interfaces
// Example:
// namespace MyNamespace;
// public class YadaViewModel : LzItemViewModelBase<Yada, YadaModel>, IYadaViewModel
// {
// }

[Generator]
public class DIHelper : IIncrementalGenerator
{
    static string[] InterfaceTargets = { "ILzTransient", "ILzSingleton", "ILzScoped" };

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the syntax provider to get class declarations
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is ClassDeclarationSyntax cds && 
                    cds.BaseList?.Types.Any(b => b.Type is IdentifierNameSyntax ins && 
                    InterfaceTargets.Contains(ins.Identifier.Text)) == true,
                transform: (context, token) =>
                {
                    var classNode = (ClassDeclarationSyntax)context.Node;
                    var scope = GetScope(classNode);
                    return (
                        Scope: scope,
                        Interface: "I" + classNode.Identifier.Text,
                        ClassName: classNode.Identifier.Text
                    );
                });

        // Combine with compilation
        var combined = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Register the source output
        context.RegisterSourceOutput(combined,
            (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<(string Scope, string Interface, string ClassName)> classes, SourceProductionContext context)
    {
        if (classes.IsEmpty)
            return;

        var namespaceName = compilation.AssemblyName!;
        var source = GenerateClassModelSource(namespaceName, classes.ToList());
        context.AddSource($"DIHelper.g.cs", source);
    }

    private static string GetScope(ClassDeclarationSyntax classNode)
    {
        foreach(var iface in classNode.BaseList?.Types!)
            if(iface.Type is IdentifierNameSyntax ins && InterfaceTargets.Contains( ins.Identifier.Text))
                switch(ins.Identifier.Text)
                {
                    case "ILzTransient": return "Transient";
                    case "ILzSingleton": return "Singleton";
                    case "ILzScoped": return "Scoped";
                }
        throw new Exception("No scope found");
    }

    private static SourceText GenerateClassModelSource(string namespaceName, List<(string scope, string interfaceName, string className)> interfaces)
    {
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine(@$"
// <auto-generated />
namespace {namespaceName};
public static class DIHelper 
{{
    public static void RegisterServices(IServiceCollection services)
    {{
");

        foreach(var iface in interfaces)
            sourceBuilder.AppendLine($"        services.TryAdd{iface.scope}<{iface.interfaceName},{iface.className}>();");

        sourceBuilder.AppendLine($@"
    }}
}}");
        SyntaxTree tree = CSharpSyntaxTree.ParseText(sourceBuilder.ToString());
        SyntaxNode root = tree.GetRoot();
        SyntaxNode formattedRoot = root.NormalizeWhitespace();
        return SourceText.From(formattedRoot.ToString(), Encoding.UTF8);
    }

    private static readonly DiagnosticDescriptor _messageRule = new(
        id: "LZI0002",
        title: "LazyMagic.LzItemViewModelGenerator Source Generator Message",
        messageFormat: "{0}",
        category: "SourceGenerator",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    private static void Log(SourceProductionContext context, string? message)
    {
        if (message == null) return;
        string[] lines = message.Split(new[] { '\n' }, StringSplitOptions.None);
        foreach (var line in lines)
        {
            var diagnostic = Diagnostic.Create(_messageRule, Location.None, line);
            context.ReportDiagnostic(diagnostic);
        }
    }
}